#!/usr/bin/env perl
use warnings;
use strict;
use FindBin;
use lib "$FindBin::Bin/lib";
use Getopt::Long;
use Term::ANSIColor;
use IO::Select;
use IPC::Open3;
use File::Find;
use File::Spec;
use File::Copy qw(cp);
use File::Basename;
use Cwd qw(abs_path);
use VircadiaBuilder::Common;
use VircadiaBuilder::Package;
use VircadiaBuilder::Package::Archive;
use VircadiaBuilder::Template;
use POSIX ();
use Data::Dumper qw(Dumper);

$| = 1;

my $prev_len = 0;
my $inst_copied = 0;
my $inst_skipped = 0;
my $inst_deleted = 0;
my %installed;

my $arch = (POSIX::uname)[4];


my $data;
my $template = VircadiaBuilder::Template->new($FindBin::Bin);


# Valid build targets for the makefile
my $all_targets = {
	'domain-server'       => { service => 1, service_desc => "Vircadia Domain Server"    , service_args => [] },
	'assignment-client'   => { service => 1, service_desc => "Vircadia Assignment Client", service_args => ["-n", "6"] },
	'ice-server'          => { service => 1, service_desc => "Vircadia ICE Server"       , service_args => [] },
	'interface'           => { service => 0 },
	'atp-client'          => { service => 0 },
	'oven'                => { service => 0 },
	'nitpick'             => { service => 0 },
	'skeleton-dump'       => { service => 0 },
	'ac-client'           => { service => 0 },
	'ktx-tool'            => { service => 0 },
	'ice-client'          => { service => 0 },
	'gpu-frame-player'    => { service => 0 },
	'vhacd-util'          => { service => 0 }
};

my @system_lib_paths;
my @x11_lib_paths;
my @system_qt_paths;

if ( $arch eq "x86_64" ) {
	@system_lib_paths = ("/usr/lib64", "/usr/lib/x86_64-linux-gnu", "/usr/lib");
	@x11_lib_paths    = (@system_lib_paths, "/usr/X11R6/lib64");
	@system_qt_paths  = ('/usr/lib64/cmake', '/usr/lib/x86_64-linux-gnu/cmake');
} elsif ( $arch eq "aarch64" ) {
	@system_lib_paths = ("/usr/lib/aarch64-linux-gnu ", "/usr/lib");
	@x11_lib_paths    = (@system_lib_paths, "/usr/X11R6/lib64");
	@system_qt_paths  = ('/usr/lib/aarch64-linux-gnu/cmake');
} else {
	fatal("Architecture $arch not supported");
}




# Libraries that don't go into an AppImage.
# Taken from https://github.com/AppImage/pkg2appimage/blob/master/excludelist
# Trimmed down a bit, as I want a minimum of requirements for installation.
#
# libnss3.so and libnssutil3.so weren't part of the original list and added
# to fix "Error initializing NSS with a persistent database"

my @excluded_system_libs = (
	qr/^ld-linux\.so\.2/,
	qr/^ld-linux-x86-64\.so\.2/,
#	qr/^libanl\.so\.1/,
#	qr/^libasound\.so\.2/,
#	qr/^libBrokenLocale\.so\.1/,
#	qr/^libcidn\.so\.1/,
#	qr/^libcom_err\.so\.2/,
	qr/^libc\.so\.6/,
	qr/^libdl\.so\.2/,
	qr/^libdrm\.so\.2/,
	qr/^libEGL\.so\.1/,
#	qr/^libexpat\.so\.1/,
	qr/^libfontconfig\.so\.1/,
	qr/^libfreetype\.so\.6/,
	qr/^libfribidi\.so\.0/,
#	qr/^libgbm\.so\.1/,
	qr/^libgcc_s\.so\.1/,
#	qr/^libgdk_pixbuf-2\.0\.so\.0/,
#	qr/^libgio-2\.0\.so\.0/,
	qr/^libglapi\.so\.0/,
	qr/^libGLdispatch\.so\.0/,
#	qr/^libglib-2\.0\.so\.0/,
	qr/^libGL\.so\.1/,
	qr/^libGLX\.so\.0/,
#	qr/^libgmp\.so\.10/,
#	qr/^libgobject-2\.0\.so\.0/,
#	qr/^libgpg-error\.so\.0/,
	qr/^libharfbuzz\.so\.0/, #fixes crash with freetype 2.11 system libraries
#	qr/^libICE\.so\.6/,
#	qr/^libjack\.so\.0/,
	qr/^libm\.so\.6/,
	qr/^libmvec\.so\.1/,
	qr/^libnss_compat\.so\.2/,
	qr/^libnss_dns\.so\.2/,
	qr/^libnss_files\.so\.2/,
	qr/^libnss_hesiod\.so\.2/,
	qr/^libnss_nisplus\.so\.2/,
	qr/^libnss_nis\.so\.2/,
	qr/^libnss3\.so/, #added - fixes crash in libsoftokn3.so
	qr/^libnssutil3\.so/, #added
	qr/^libOpenGL\.so\.0/, #fixes GLVND on different vendor systems
#	qr/^libp11-kit\.so\.0/,
#	qr/^libpango-1\.0\.so\.0/,
#	qr/^libpangocairo-1\.0\.so\.0/,
#	qr/^libpangoft2-1\.0\.so\.0/,
	qr/^libpthread\.so\.0/,
	qr/^libresolv\.so\.2/,
	qr/^librt\.so\.1/,
#	qr/^libSM\.so\.6/,
	qr/^libstdc\+\+\.so\.6/,
#	qr/^libthai\.so\.0/,
	qr/^libthread_db\.so\.1/,
#	qr/^libusb-1\.0\.so\.0/,
	qr/^libutil\.so\.1/,
#	qr/^libuuid\.so\.1/,
#	qr/^libX11\.so\.6/,
#	qr/^libxcb-dri2\.so\.0/,
#	qr/^libxcb-dri3\.so\.0/,
#	qr/^libxcb\.so\.1/,
#	qr/^libz\.so\.1/
);

# Some libraries are loaded at runtime, and therefore can't be found with ldd.
# Failing to add them to the appimage results in them being loaded from the host system,
# often resulting in a crash.
#
# The listed names will be searched in the directories listed in @system_lib_paths
#
#
# Debugging advice:
# * use 'pipe info sharedlibrary | grep -v tmp' to quickly see which host libraries are loaded
# * use 'set stop-on-solib-events 1' to stop on library load.
# * use 'break dlopen' to stop on dlopen (library load)

my @included_system_libs = (
	qr/^libxcb/,
	qr/^libxkb/,
	qr/^opensc-/,
	qr/^libopensc.so/,
	qr/^p11-kit-proxy.so/
);

my $optimization_presets = {
	native      => {
		description => "Build code optimized for this specific machine. Not suitable for packaging or copying to other systems.",
		flags       => '-march=native -mtune=native',
	},
	compatible  => {
		description => "Build code optimized for SSE3 (or without architecture optimization on aarch64). This should work on almost anything.",
	},
	none => {
		description => "Do not perform any CPU-specific optimizations. Suitable for any hardware.",
	}
};

if ( $arch eq "x86_64" ) {
	$optimization_presets->{compatible}->{flags} = '-msse3';
	$optimization_presets->{none}->{flags} = '-march=x86-64';
} elsif ( $arch eq "aarch64" ) {
	$optimization_presets->{compatible}->{flags} = '';
	$optimization_presets->{none}->{flags} = '';
} else {
	fatal("Architecture $arch not supported");
}

my $appimagetool_url;
my $appimagetool_release = 13;
if ( $arch eq "x86_64" ) {
	$appimagetool_url = "https://github.com/AppImage/AppImageKit/releases/download/${appimagetool_release}/appimagetool-x86_64.AppImage";
} elsif ( $arch eq "aarch64" ) {
	$appimagetool_url = "https://github.com/AppImage/AppImageKit/releases/download/${appimagetool_release}/appimagetool-aarch64.AppImage";
} else {
	fatal("Architecture $arch not supported");
}



# Amount of RAM needed to build Vircadia, per compiler process.
my $mem_per_core_vircadia = 1 * 1024 * 1024;

# Qt has a build stage that consumes a huge amount of RAM. Be a bit conservative here.
my $mem_per_core_qt     = 1.2 * 1024 * 1024;

my $repo;
my $qt_repo      = "git://code.qt.io/qt/qt5.git";
my $repo_tag;

my $root_dir;    # Base directory, eg, $HOME/Overte.
my $inst_dir;    # Installation dir, subdirectory under $root_dir. Eg, $root_dir/install";
my $binary_dir;  # Where the final binaries are found
my $files_dir    = "$ENV{HOME}/overte-files"; # Where cmake downloads files to

my $rel_type     = "DEV"; # DEV by default.
my $rel_no       = "";
my $build_no     = "";

my $build_cores;
my $build_cores_qt;
my $optimization_level;

my $desktop;
my $distro;
my $architecture;


my $using_system_qt;

my ($opt_keep_source, $opt_auto, $opt_build_qt, $opt_build, $opt_skip_build, $opt_skip_systemd_restart, $opt_no_modify_rpath, $opt_skip_install, $opt_make_appimage, $opt_install_deps_only, $opt_verbose);
my ($opt_qt_debug, $opt_qt_debug_info, $cmd_get_install_dir, $cmd_get_archive_name, $cmd_make_archive, $opt_debug);
my ($cmd_help, $cmd_get_supported, $cmd_get_source_deps, $cmd_get_qt_deps, $cmd_get_system_qt_deps, $cmd_get_qt_version, $cmd_get_qt_patches, $cmd_make_pkglist);
my ($opt_fork, $opt_fork_appimage_id, $opt_pr, $opt_disable_sanity_check);
my $build_type = "RelWithDebInfo";


$opt_build = "client";

my @build_list;



GetOptions(
	"keep-source|K"          => \$opt_keep_source,
	"help|h"                 => \$cmd_help,
	"auto|y"                 => \$opt_auto,
	"repo|r=s"               => \$repo,
	"tag|t=s"                => \$repo_tag,
	"build-type|T=s"         => \$build_type,
	"release-type=s"         => \$rel_type,
	"release-number=s"       => \$rel_no,
	"build-number=s"         => \$build_no,
	"destdir|d=s"            => \$root_dir,
	"cores|j=i"              => \$build_cores,
	"qt-cores|J=i"           => \$build_cores_qt,
	"collect-info|C"         => \$VircadiaBuilder::Common::collect_system_info,
	"distro|D=s"             => \$distro,
	"build-qt|B"             => \$opt_build_qt,
	"build|U=s"              => \$opt_build,
	"get-supported"          => \$cmd_get_supported,
	"get-source-deps=s"      => \$cmd_get_source_deps,
	"get-qt-deps=s"          => \$cmd_get_qt_deps,
	"get-system-qt-deps=s"   => \$cmd_get_system_qt_deps,
	"get-qt-version=s"       => \$cmd_get_qt_version,
	"get-qt-patches=s"       => \$cmd_get_qt_patches,
	"get-install-dir"        => \$cmd_get_install_dir,
	"get-archive"            => \$cmd_get_archive_name,
	"make-pkglist"           => \$cmd_make_pkglist,
	"make-appimage|A"        => \$opt_make_appimage,
	"make-archive"           => \$cmd_make_archive,
	"skip-build"             => \$opt_skip_build,
	"skip-install"           => \$opt_skip_install,
	"skip-systemd-restart"   => \$opt_skip_systemd_restart,
	"no-modify-rpath"        => \$opt_no_modify_rpath,
	"qt-debug"               => \$opt_qt_debug,
	"qt-debug-info"          => \$opt_qt_debug_info,
	"install-deps-only"      => \$opt_install_deps_only,
	"verbose|v"              => \$opt_verbose,
        "debug"                  => \$opt_debug,
        "optimization-level=s"   => \$optimization_level,
	"fork|F=s"               => \$opt_fork,
	"pr|P=s"                 => \$opt_pr,
	"disable-sanity-check"   => \$opt_disable_sanity_check,
) or help(1);

@build_list = parse_build_option($opt_build);
if ( $opt_make_appimage ) {
	# If we're building an AppImage, and no level has been manually specified, default to 'compatible'
	$optimization_level //= "compatible";
} else {
	# Otherwise we build for the local system specifically
	$optimization_level //= "native";
}

if (!optimization_preset_is_valid($optimization_level)) {
	list_optimization_presets();
	exit(1);
}

load_data();



my $custom_fork;
my $fork_name;

if ( $opt_pr ) {
	if ( $opt_pr =~ m#https://github.com/vircadia/vircadia/pulls/(\d+)# ) {
		$opt_pr = $1;
		$opt_fork = "vircadia";
		$files_dir = "$ENV{HOME}/vircadia-files";
	} elsif ( $opt_pr =~ m#https://github.com/overte-org/overte/pull/(\d+)# ) {
		$opt_pr = $1;
		$opt_fork = "overte";
		$files_dir = "$ENV{HOME}/overte-files";
	} elsif ( $opt_pr =~ m#https://github.com/tivolicloud/interface/pull/(\d+)# ) {
		$opt_pr = $1;
		$opt_fork = "tivoli";
		$files_dir = "$ENV{HOME}/tivoli-files";
	} elsif ( $opt_pr =~ m#https://github.com/(\w+)/(\w+)/pull/(\d+)# ) {
		$opt_fork = $1;
		$repo     = "https://github.com/$1/$2";
		$opt_pr = $3;
		$files_dir = "$ENV{HOME}/overte-files";

		# This ensures we don't fail due to an unrecognized fork name later.
		$custom_fork = 1;
	} elsif ( $opt_pr =~ /^(\d+)/ ) {
		# Nothing, PR number specified as-is
	} else {
		die "Invalid argument to --pr. Either pass a PR number, or a full URL to the PR on github";
	}
}

if ( !$opt_fork) {
	my $exe = basename($0);
	if ( $exe =~ /vircadia/i ) {
		$opt_fork = "vircadia";
	} elsif ( $exe =~ /overte/i ) {
		$opt_fork = "overte";
	} elsif ( $exe =~ /tivoli/ ) {
		$opt_fork = "tivoli";
	} else {
		warn "--fork not specified, and can't determine fork from filename. Defaulting to vircadia";
		$opt_fork = "vircadia";
	}

	debug("Selected fork $opt_fork based on our filename $0\n");
}

$opt_fork = lc($opt_fork);

if ( $opt_fork eq "vircadia" ) {
	$fork_name = "Vircadia";
	$repo     //= "https://github.com/vircadia/vircadia";
	$repo_tag //= "master";
	$opt_fork_appimage_id = "com.vircadia.interface";

	$template->fork_id("Vircadia");
	$template->fork_name("Vircadia");

} elsif ( $opt_fork eq "overte" ) {
	$fork_name = "Overte";
	$repo     //= "https://github.com/overte-org/overte";
	$repo_tag //= "master";
	$opt_fork_appimage_id = "org.overte.interface";

	$template->fork_id("Overte");
	$template->fork_name("Overte");
} elsif ( $opt_fork eq "tivoli" ) {
	$fork_name = "Tivoli";
	$repo     //= "https://github.com/tivolicloud/interface";
	$repo_tag //= "main";
	$opt_fork_appimage_id = "com.tivolivr.interface";

	$template->fork_id("Tivoli");
	$template->fork_name("Tivoli VR");
} else {
	die "Unrecognized fork: $opt_fork" unless ($custom_fork);
}




debug("Fork is $fork_name, repo $repo\n");

$root_dir     //= "$ENV{HOME}/$fork_name";
$inst_dir     //= "$root_dir/install"; # Where files will be installed
$binary_dir   //= $inst_dir;           # Where the final binaries are found

help(1) if ($cmd_help);

get_supported() if ( $cmd_get_supported );
get_conf( 'source_dependencies', $cmd_get_source_deps ) if ( $cmd_get_source_deps );
get_conf( 'qt_source_dependencies', $cmd_get_qt_deps )  if ( $cmd_get_qt_deps );
get_conf( 'system_qt_dependencies', $cmd_get_system_qt_deps ) if ( $cmd_get_system_qt_deps );
get_conf( 'qt_version', $cmd_get_qt_version )           if ( $cmd_get_qt_version );
get_conf( 'qt_patches', $cmd_get_qt_patches )           if ( $cmd_get_qt_patches );
make_pkglist()                                          if ( $cmd_make_pkglist );



init_log();




$build_cores    //= calculate_cores($fork_name, $mem_per_core_vircadia);
$build_cores_qt //= calculate_cores("Qt", $mem_per_core_qt);
$desktop        //= get_desktop();
$distro         //= detect_distro();
$architecture   //= detect_arch();


if ( !exists $data->{$distro} ) {
	fatal("No configuration for $distro, distribution unsupported.");
}

my $DD = $data->{$distro};

my %PACKAGES = get_package_list();
set_environment();

# We need to build Qt if:
# A. The user explicitly wants to build it
# B. Both of these are the case:
#    * There's no binary package
#    * System Qt is not supported.
my $need_to_build_qt = $opt_build_qt || (!$DD->{has_binary_qt_package}  && !$DD->{system_qt_dependencies});

if ( $DD->{system_qt_dependencies} ) {
		$using_system_qt = 1;
}

install_missing_packages();

exit(0) if ( $opt_install_deps_only );

import_nvm_environment();
collect_info();


unless($opt_skip_build) {
	get_source();
	$template->version(get_source_version());

	$inst_dir = get_install_dir_path();
	$binary_dir = $opt_skip_install ? "$root_dir/build" : $inst_dir;

	install_qt() if ($need_to_build_qt);
	build();
} else {
	$template->version(get_source_version());
}

# Ensure the paths are set if we didn't build
$inst_dir = get_install_dir_path();
$binary_dir = $opt_skip_install ? "$root_dir/build" : $inst_dir;

setup_qt() if ($need_to_build_qt);
adjust_library_paths() unless ($opt_no_modify_rpath);

if ( $opt_make_appimage ) {
	download_appimage_tool();
	install_into_appimage();
} elsif ($cmd_make_archive) {
	install();
	setup_scripts();
	create_archive();
} else {
	install() unless ($opt_skip_install);
	setup_scripts();
	setup_services();
	setup_desktop();
}

sub load_data {
	my $confpath = "$FindBin::Bin/distros";
	opendir(my $dfh, $confpath) or die "Can't find distros directory at $confpath";
	while(my $filename = readdir($dfh)) {
		next if ( -d "$confpath/$filename" );
		if ( $filename =~ /.cfg$/ ) {
			my $distro_name = basename($filename, ".cfg");
			$data->{$distro_name} = do("$confpath/$filename");
		}
	}
}

sub detect_distro {
	info("Detecting distribution... ");

	if ( -f "/etc/os-release" ) {
		my @release_info = readfile("/etc/os-release");
		my %release_data;

		debug("Parsing /etc/os-release...\n");
		foreach my $line (@release_info) {
			$line =~ s/#.*$//;
			my ($k, $v);

			if (($k, $v) = $line =~ /^(\w+)=(.*?)$/) {
				$v =~ s/^"//;
				$v =~ s/"$//;

				$release_data{$k} = $v;
				debug("\t$k => '$v'\n");
			}
		}

		my $id          = $release_data{ID};
		if (defined $release_data{VERSION_ID}) {
			# Not all distros have a VERSION_ID
			$id .= "-" . $release_data{VERSION_ID};
		}

		my $pretty_name = $release_data{PRETTY_NAME} // ( $release_data{NAME} . " " . $release_data{VERSION} );

		if ( $release_data{ID} eq "opensuse-tumbleweed" || $release_data{ID} eq "manjaro" || $release_data{ID} eq "manjaro-arm" ||
		     $release_data{ID} eq "arch" ) {
			$id = $release_data{ID};

			# Opensuse Tumbleweed is a rolling release, and VERSION_ID is a timestamp, so it changes
			# far too often. For now we're just going to assume that people stay up to date and only
			# supporting the latest is needed.
			# Manjaro and Arch are rolling release, and VERSION_ID does not exist.
		}

		if ( $release_data{ID} eq "debian" && $release_data{PRETTY_NAME} =~ m/bookworm/ ) {
			$id = "debian-bookworm";

			# Debian Bookworm is in testing and therefore doesn't have a VERSION_ID yet.
			# While the VERSION_ID will change to "12" in the future, we are using "bookworm"
			# here to emphasize that bookworm has not been released yet.
		}

		info_ok("$pretty_name ($id)\n");
		return $id;
	}

	fatal("Failed to detect distribution! Couldn't find /etc/os-release.");
}

sub detect_arch() {
	info "Detecting architecture... ";
	my $arch = `uname -m`;
	chomp $arch;

	info_ok($arch . "\n");

	return $arch;
}

sub get_package_list {
	info("Getting the package list... ");
	if (!defined $DD->{package_manager}) {
		fatal("Internal error: Package manager not defined for current distribution '$distro'. Data dump: " . Dumper([$DD]));
	}

	my @packages;
	if ( $DD->{package_manager} eq "dnf" || $DD->{package_manager} eq "yum" || $DD->{package_manager} eq "zypper" ) {
		@packages = read_from_cmd("rpm", "-qa", "--qf", "%{NAME}\\n");
	} elsif ( $DD->{package_manager} eq "apt" ) {
		@packages = read_from_cmd("dpkg-query", "--show", "-f", "\${Package}\n");
	} elsif ( $DD->{package_manager} eq "pacman" ) {
		@packages = read_from_cmd("pacman", "-Qq");
	} elsif ( $DD->{package_manager} eq "none" ) {
		# Nothing
	} else {
		fatal("Internal error: unknown package manager " . $DD->{package_manager});
	}

	chomp @packages;

	info_ok("done.\n");
	return map { $_ => 1 } @packages;
}

sub set_environment {
	if ( exists $DD->{environment} ) {
		info("Setting environment... ");

		foreach my $var ( keys %{ $DD->{environment} } ) {
			$ENV{$var} = $DD->{environment}->{$var};
			info_ok("$var ");
		}

		info_ok("\n");
	}

}

sub install_missing_packages {
	my @required_packages = @{$DD->{source_dependencies}};

	info("Checking Qt availability... ");

	if ( $DD->{system_qt_dependencies} && !$need_to_build_qt ) {
		info_ok(" system Qt available.\n");
		push @required_packages, @{ $DD->{system_qt_dependencies}};
	} elsif ( $DD->{has_binary_qt_package} && !$need_to_build_qt) {
		info_ok(" binary Qt package available.\n");
	} else {
		push @required_packages, @{ $DD->{qt_source_dependencies}};

		warning(" no system Qt support, nor binary package\n\n");

		warning("System Qt is not supported on your system, and there is no binary\n");
		warning("Qt package available either.\n\n");
		warning("This script will build it for you, but it can take a long time,\n");
		warning("up to several hours, depending on hardware capabilities.\n\n");
		warning("Fortunately, it only needs to be built once.\n\n");
	}

	if ( $opt_make_appimage ) {
		push @required_packages, @{ $DD->{appimage_dependencies} };
	}

	info("Checking if any packages need installing... ");


	my @missing = grep { !exists $PACKAGES{$_} } @required_packages;
	my $failed;

	if ( @missing ) {
		print scalar(@missing) . " additional packages needed: " . join(", ", @missing) . "\n";

		if ( $DD->{package_manager} eq "dnf" ) {
			sudo_run("dnf", "install", "-y", @missing);
		} elsif ( $DD->{package_manager} eq "yum" ) {
			sudo_run("yum", "install", "-y", @missing);
		} elsif ( $DD->{package_manager} eq "apt" ) {
			$ENV{DEBIAN_FRONTEND} = 'noninteractive';
			sudo_run("apt-get", "update");
			my $ret = sudo_run({ fail_ok => 1, get_retval => 1 }, "--preserve-env=DEBIAN_FRONTEND", "apt-get", "install", "-y", "--no-remove", @missing);
			if ( $ret->{retval} > 0 ) {
				$failed = 1;
			}
		} elsif ( $DD->{package_manager} eq "pacman" ) {
			sudo_run("pacman", "-S", "--noconfirm", @missing);
		} elsif ( $DD->{package_manager} eq "zypper" ) {
			sudo_run("zypper", "--non-interactive", "install", @missing);
		} elsif ( $DD->{package_manager} eq "none" ) {
			# Nothing
		} else {
			fatal("Internal error: unknown package manager " . $DD->{package_manager});
		}

		if ( $failed ) {
			warning("\nFailed to install packages\n");
			diagnose_package_install_error(@missing);
			exit(1);
		} else {
			info_ok("\nPackages have been installed, please run $0 again.\n\n");
			exit(0);
		}
	} else {
		info_ok("no, all " . scalar(@required_packages) . " required packages are present.\n");
	}
}


sub diagnose_package_install_error {
	my (@packages) = @_;
	info("Trying to diagnose package install problem. Please wait, this may take a while.\n");
	info("Checking: ");

	my @would_remove;
	my @other_errors;



	foreach my $pkg ( @packages ) {
		if ( $DD->{package_manager} eq "dnf" ) {
			# TODO
		} elsif ( $DD->{package_manager} eq "yum" ) {
			# TODO
		} elsif ( $DD->{package_manager} eq "apt" ) {
			info("$pkg ");
			$ENV{DEBIAN_FRONTEND} = 'noninteractive';

			my $ret_norem = run({ fail_ok => 1, get_retval => 1, quiet => 1 }, "apt-get", "install", "-y", "--no-remove", "-s", $pkg);
			my $ret       = run({ fail_ok => 1, get_retval => 1, quiet => 1 }, "apt-get", "install", "-y", "-s", $pkg);

			info("(" . $ret_norem->{retval} . "/" . $ret->{retval} . "), ");
			if ( $ret_norem->{retval} > 0 && $ret->{retval} == 0 ) {
				push @would_remove, $pkg;
			} elsif ( $ret->{retval} > 0 ) {
				push @other_errors, $pkg;
			}
		} elsif ( $DD->{package_manager} eq "pacman" ) {
			# TODO
		} elsif ( $DD->{package_manager} eq "zypper" ) {
			# TODO
		} elsif ( $DD->{package_manager} eq "none" ) {
			# Nothing
		} else {
			fatal("Internal error: unknown package manager " . $DD->{package_manager});
		}
	}

	info_ok("done\n\n");
	if ( @would_remove ) {
		warning("Installing these packages would require uninstalling packages from your system: " . join(', ', @would_remove) . "\n");
	}
	if ( @other_errors ) {
		warning("These packages can't be installed in your system: " . join(', ', @other_errors) . "\n");
	}

	fatal("$0 failed to install required dependencies. Please look at the output above, there may be some clues as to what is the problem.\n".
	      "Also, try to install any updates to your Linux distribution");


}

sub import_nvm_environment {
	# Amazon Linux 2 is a huge pain to deal with. The official instructions as per:
	# https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/setting-up-node-on-ec2-instance.html
	# require running a random shell script off the web, and sourcing a script to get the environment vars.
	#
	# For the sake of user friendliness we'd like to avoid making the user modify their profile.
	#
	# So we're counting on that install_amazon_linux_deps.sh did the installation work, and then we'll try
	# and import the environment into our process by calling nvm.sh, env, and parsing that.

	info("Checking for NPM... ");
	if (!-x "/usr/bin/npm" && !-x "/usr/local/bin/npm") {
		if ( -f "$ENV{HOME}/.nvm/nvm.sh" ) {
			info_ok("NVM found, importing environment... ");
			my $shell;
			my $var_data;


			# On Ubuntu 18.04, /bin/sh is dash, which doesn't recognize the source command.
			# We try and force using bash if at all possible. If that doesn't work, we'll
			# try whatever Perl wants to invoke, but that might not work.
			foreach my $sh (qw(/bin/bash /usr/bin/bash)) {
				if ( -x "$sh") {
					$shell = $sh;
					info_ok("Found bash in $sh; ");
				}
			}

			if ( $shell ) {
				$var_data = run({keep_buf => 1}, $shell, "-c", "source \"$ENV{HOME}/.nvm/nvm.sh\" && env --null");
			} else {
				warning("Failed to find bash, this might fail;");
				$var_data = run({keep_buf => 1}, "source \"$ENV{HOME}/.nvm/nvm.sh\" && env --null");
			}

			foreach my $var_line (split(/\0/, $var_data)) {
				chomp $var_line;
				my ($k, $v) = split(/=/, $var_line);

				if ( $k =~ /^NVM/ || $k eq "PATH" ) {
					# Import NVM_* and PATH variables to our local environment
					info_ok("$k ");
					debug("$k => $v");
					$ENV{$k} = $v;
				}
			}

			if ( $ENV{PATH} =~ /\.nvm/ ) {
				# Sanity check
				info_ok("imported, looks good.\n");
			} else {
				warning("imported, may not have worked.\n");
			}
		} else {
			warning("Not found installed, NPM not found. Build may fail.\n");
		}
	} else {
		info_ok("Found installed, all good.\n");
	}
}


sub collect_info {
	require Term::ReadLine;
	info("\n");
	important("Everything seems to be in order. I am going to ask you some questions now.\n");
	important("The defaults should be just fine. Simply press ENTER to accept the suggested\n");
	important("value.\n\n");
	important("By default, the code will be compiled to target your specific hardware.\n");
	important("If you are going to deploy this build on another machine, choose the 'compatible'\n");
	important("optimization level. It will be automatically selected by default for AppImage builds.\n\n");


	my $opt_levels = "";
	foreach my $lvl ( sort keys %$optimization_presets ) {
		$opt_levels .= ", " if ($opt_levels);
		$opt_levels .= $lvl;
	}
	$opt_levels .= " or help";

	my $rl = Term::ReadLine->new('vircadia_setup');
	my $ok = $opt_auto ? "yes" : "no";

	while($ok ne "yes") {
		$repo            = $rl->readline("Git repository             : ", $repo);
		$repo_tag        = $rl->readline("Git tag                    : ", $repo_tag);
		$rel_type        = $rl->readline("Release type               : ", $rel_type);
		$build_type      = $rl->readline("Build type                 : ", $build_type);
		$rel_no          = $rl->readline("Release number             : ", $rel_no);
		$build_no        = $rl->readline("Build number               : ", $build_no);
		$root_dir        = $rl->readline("Installation dir           : ", $root_dir);
		$build_cores     = $rl->readline("CPU cores to use for $fork_name: ", $build_cores);
		$build_cores_qt  = $rl->readline("CPU cores to use for Qt5   : ", $build_cores_qt);

		my $first_time=1;
		while( $first_time || !optimization_preset_is_valid($optimization_level)) {
			$optimization_level = $rl->readline("Optimization level ($opt_levels): ", $optimization_level);

			if (!optimization_preset_is_valid($optimization_level)) {
				list_optimization_presets();
			}

			undef $first_time;
		}


		info("\n");
		$ok = $rl->readline("If the above is okay, say 'yes' to begin installation: ", "yes");
	}

	if ( defined $rel_no ) {
		$ENV{RELEASE_NUMBER} = $rel_no;
	}

	if ( defined $build_no ) {
		$ENV{BUILD_NUMBER} = $build_no;
	}

	if ( lc($rel_type) eq "production" ) {
		$ENV{RELEASE_TYPE} = 'PRODUCTION';
		$ENV{PRODUCTION_BUILD} = 1;
		$ENV{USE_STABLE_GLOBAL_SERVICES} = 1;
		$ENV{BUILD_GLOBAL_SERVICES} = 'STABLE';
	}

	if ( lc($rel_type) eq "pr" ) {
		$ENV{RELEASE_TYPE} = 'PR';
		$ENV{PR_BUILD} = 1;
	}

	if ( lc($rel_type) eq "dev" ) {
		$ENV{RELEASE_TYPE} = 'DEV';
		$ENV{DEV_BUILD} = 1;
		$ENV{BUILD_GLOBAL_SERVICES} = 'DEVELOPMENT';
	}
}


sub get_source {
	info("\n\n");
	important("############################################################\n");
	important("# Starting installation\n");
	important("############################################################\n");
	info("\n");

	mkdir($root_dir);

	get_source_from_git($repo, "source", $repo_tag, no_submodules => 0, pr => $opt_pr);
}

sub build {
	info("\n\n");
	important("############################################################\n");
	important("# Building\n");
	important("############################################################\n");
	info("\n");


	if ( $DD->{system_qt_dependencies} ) {
		important("Using system Qt\n");
		$ENV{VIRCADIA_USE_SYSTEM_QT} = 1;
		$ENV{OVERTE_USE_SYSTEM_QT} = 1;

		$using_system_qt = 1;
	} elsif ( check_qt_install() ) {
		important("Using compiled Qt\n");
		$ENV{QT_CMAKE_PREFIX_PATH}="$root_dir/qt5-install/lib/cmake";

		# hifi_qt.py in the master merge branch looks for Qt in:
		# $HIFI_QT_BASE/$VIRCADIA_USE_QT_VERSION/qt5-install
		#
		# We do a horrid hack here, where $VIRCADIA_USE_QT_VERSION is
		# an empty string, but still has a value, and $HIFI_QT_BASE
		# points to the root dir, where a qt5-install directory happens
		# to exist.
		#
		# This will be redone later, once the merge is complete and a
		# less ugly way of specifying an external Qt can be introduced.
		$ENV{VIRCADIA_USE_PREBUILT_QT}=1;
		$ENV{VIRCADIA_USE_QT_VERSION}="";

		$ENV{OVERTE_USE_PREBUILT_QT}=1;
		$ENV{OVERTE_USE_QT_VERSION}="";

		$ENV{HIFI_QT_BASE} = "$root_dir";

		# Finally, the single, clean solution to the issue, after PR #936
		# The above is obsolete, and can be removed after a while.
		# Suggested cleanup date: Jan 1, 2022.
		$ENV{VIRCADIA_QT_PATH} = "$root_dir/qt5-install";
		$ENV{OVERTE_QT_PATH} = "$root_dir/qt5-install";

	}


	$ENV{HIFI_VCPKG_BASE} = "$root_dir/vcpkg";

	if ( -d "$root_dir/build" ) {
		run("rm", "-rf", "$root_dir/build");
	}

	mkdir("$root_dir/build");
	chdir("$root_dir/build");

	my @cmake_extra_opts;
	if ( $opt_debug ) {
		if ( $fork_name eq "Overte" ) {
			push @cmake_extra_opts, "-DOVERTE_OPTIMIZE=0";
		} else {
			push @cmake_extra_opts, "-DVIRCADIA_OPTIMIZE=0";
		}
	} else {
		if ( exists $optimization_presets->{$optimization_level} ) {
			if ( $fork_name eq "Overte" ) {
				push @cmake_extra_opts, "-DOVERTE_CPU_ARCHITECTURE=" . $optimization_presets->{$optimization_level}->{flags};
			} else {
				push @cmake_extra_opts, "-DVIRCADIA_CPU_ARCHITECTURE=" . $optimization_presets->{$optimization_level}->{flags};
			}
		}
	}

	push @cmake_extra_opts, "-DCMAKE_BUILD_TYPE=${build_type}";
	push @cmake_extra_opts, "-DJSDOC_ENABLED:BOOL=TRUE";

	if ( $DD->{cmake_extra_arguments} ) {
		debug("Adding extra CMake arguments from config: " . join(';',  @{ $DD->{cmake_extra_arguments} }) );
		push @cmake_extra_opts, @{ $DD->{cmake_extra_arguments} };
	}

	important("Running cmake " . join(' ', @cmake_extra_opts) . "\n");

	run($DD->{cmake}, "../source", @cmake_extra_opts);
	my @make_extra_opts;

	if ( $opt_verbose ) {
		push @make_extra_opts,"VERBOSE=1"
	}


	foreach my $target (@build_list) {
		important("Building target $target\n");
		run("make", $target, "-j${build_cores}", @make_extra_opts);
	}

	if (!$using_system_qt) {
		# The one in lib/ doesn't have a rpath, which causes quazip to link against system Qt, which causes interface to link against
		# both system Qt and custom Qt. This leads to problems.
		#
		# This probably needs a cmake fix. See https://github.com/vircadia/vircadia/issues/308

		info("Checking for libquazip linking issue... ");
		my ($quazip_in_lib)   = grep { -f $_ && ! -l $_ } glob("$root_dir/build/ext/makefiles/quazip/project/lib/libquazip5.so*");
		my ($quazip_in_build) = grep { -f $_ && ! -l $_ } glob("$root_dir/build/ext/makefiles/quazip/project/build/libquazip5.so*");

		if ( $quazip_in_lib && $quazip_in_build ) {
			my $lib_rpath   = read_from_cmd("patchelf", "--print-rpath", $quazip_in_lib); chomp $lib_rpath;
			my $build_rpath = read_from_cmd("patchelf", "--print-rpath", $quazip_in_build); chomp $build_rpath;

			if ( $lib_rpath eq "" && $build_rpath ne "" ) {
				cp($quazip_in_build, $quazip_in_lib) or fatal("Can't copy $quazip_in_build to $quazip_in_lib");
				info_ok("issue found, corrected\n");
			} else {
				info_ok("everything looks okay\n");
			}
		} else {
			warning("lib/libquazip5.so* not found; ") unless ($quazip_in_lib);
			warning("build/libquazip5.so* not found; ") unless ($quazip_in_build);
			info_ok("skipping\n");
		}
	}

}

sub adjust_library_paths {
	info("\n\n");
	important("############################################################\n");
	important("# Adjusting library paths\n");
	important("############################################################\n");
	info("\n");


	chdir("$root_dir/build");
	find(\&adjust_libs_search_func, "$root_dir/build");

}

sub install {
	info("\n\n");
	important("############################################################\n");
	important("# Installing\n");
	important("############################################################\n");
	info("\n");

	info("Copying files to install directory...\n");


	find({ follow       => 1,
	       follow_skip  => 2,
	       wanted       => sub { install_search_func("$root_dir/build", $inst_dir, "link") }},
	       "$root_dir/build");

	#find({ follow => 1, follow_skip => 2, wanted => \&install_search_func }, "$root_dir/build");

	# Clear line
	info( "\r" . (" " x $prev_len) . "\r");


	info("Cleaning up install directory...");
	find(\&install_clean_func, $inst_dir);
	info_ok("done\n");

	info("Copied : "); info_ok("$inst_copied\n");
	info("Skipped: "); info_ok("$inst_skipped\n");
	info("Deleted: "); info_ok("$inst_deleted\n");
}

sub create_archive {
	info("\n\n");
	important("############################################################\n");
	important("# Creating achive\n");
	important("############################################################\n");
	info("\n");

	if (!exists $DD->{packaging}) {
		fatal("Packaging not implemented for this distribution");
	}

	my $archive = VircadiaBuilder::Package::Archive->new();
	$archive->set_version( get_source_version() );
	$archive->set_install_dir( $inst_dir );
	$archive->set_packaging_data( $DD->{packaging} );
	$archive->set_targets( @build_list );

	my $dest_file = $archive->get_output_file();
	info("Writing into $dest_file... ");

	if ( $archive->build() ) {
		my $size = int((-s $dest_file) / (1024*1024));
		info_ok("done, $size MiB written.\n");
	} else {
		error("Failed!");
	}
}


sub  install_search_func {
	my ($source, $destination, $method) = @_;

	my $abspath = $File::Find::name;
	my $relpath = File::Spec->abs2rel($abspath, $source);
	my $file = $_;

	info( "\r" . (" " x $prev_len) . "\r". $relpath );
	$prev_len = length($relpath);


	my $keep;
	my $skip;


	# All libraries are to be kept
	$keep = 1 if ( $file =~ /\.so$/ || $file =~ /\.so\.\d+$/ || $file =~ /\.so\.\d+\.\d+/ || $file =~ /\.so\.\d+\.\d+\.\d+/ );


	# Otherwise, nothing from the ext directory is to be kept
	$skip = 1 if ( $relpath =~ /^ext\// );

	$skip = 1 if ( $relpath =~ /.cmake$/ || $relpath =~ /CMake/ || $relpath =~ /_CPack_Packages/ );

	$skip = 1 if ( $relpath =~ "Makefile" );

	$skip = 1 if ( $relpath =~ /_autogen/ );

	$skip = 1 if ( $relpath =~ /\.h$/ || $relpath =~ /\.cpp$/ );

	$skip = 1 if ( $relpath =~ /_env/ );

	$skip = 1 if ( $relpath =~ /interface_manifest.txt/ );

	if ( $keep || !$skip) {
		if ( -f $abspath ) {
			my $reldir  = dirname($relpath);
			debug("COPY: '$abspath' => '$destination/$relpath'\n");

			mkdir_path("$destination/$reldir");
			unlink("$destination/$relpath") if ( -e "$destination/$relpath" );

			if ( -l $abspath ) {
				# Turns out that trying to make a hardlink of a symlink copies the symlink
				if ( $method eq "copy" ) {
					symlink(readlink($abspath), "$destination/$relpath");
				} elsif ( $method eq "link" ) {
					link(readlink($abspath), "$destination/$relpath") or die "Can't link " . readlink($abspath) . " to $destination/$relpath: $!";
				} else {
					fatal("Unrecognized install method: $method");
				}
			} else {
				if ( $method eq "copy" ) {
					cp($abspath, "$destination/$relpath") or die "Can't copy $abspath to $destination/$relpath: $!";
				} elsif ( $method eq "link" ) {
					link($abspath, "$destination/$relpath") or die "Can't link $abspath to $destination/$relpath: $!";
				} else {
					fatal("Unrecognized install method: $method");
				}
			}

			$installed{$relpath} = 1;
			$inst_copied++;
		}
	} else {
		debug("SKIP: '$abspath'\n");
		$inst_skipped++;
	}
}


sub install_clean_func {
	my $abspath = $File::Find::name;
	my $relpath = File::Spec->abs2rel($abspath, $inst_dir);
	my $file = $_;

	if ( -f $abspath && !exists $installed{$relpath} ) {
		debug("DEL: '$abspath'\n");
		unlink($abspath);
		$inst_deleted++;
	}

}

sub adjust_libs_search_func {
	my $abspath = $File::Find::name;
	my $relpath = File::Spec->abs2rel($abspath, "$root_dir/build");


	# Don't touch cmake things
	return if ( $relpath =~ /CMakeFiles/ );

	# Do not run on Amazon Linux 2 as it does not have patchelf
	if ( -f $abspath && -x $abspath && is_elf($abspath) )  {
		patch_rpath($abspath, $File::Find::dir);
	}
}

sub patch_rpath {
	my ($abs_binpath, $basedir) = @_;

	my $rel_binpath = File::Spec->abs2rel($abs_binpath, "$root_dir/build");



	info("Adjusting $rel_binpath... ");

	my $cur_rpath = read_from_cmd("patchelf", "--print-rpath", $abs_binpath);
	my $new_rpath;

	chomp $cur_rpath;

	my @paths = split(/:/, $cur_rpath);
	my @result;

	my $changes = 0;
	my $failures = 0;
	my $kept = 0;


	foreach my $p (@paths) {
		if ( $p =~ /^\// ) {
			my $new_rel = File::Spec->abs2rel($p, $basedir);
			my $new_val = '$ORIGIN/' . $new_rel;

			debug("\t$p => $new_val\n");

			if ( -e $p && ! -e "$basedir/$new_rel" ) {
				# Sanity check: verify that if the previous path existed,
				# the new one does too.
				warning("Verification failed for changing library path $p => $basedir/$new_rel! There may be symlinks in the path.\n");
				$failures++;
			}

			$changes++;
			push @result, $new_val;
		} else {
			$kept++;
			push @result, $p;
		}
	}


	$new_rpath = join(':', @result);

	if ( !$changes ) {
		info_ok("no change needed\n");
	} else {
		if ( !$failures ) {
			info_ok("$changes changed, $kept kept");
			run("patchelf", "--set-rpath", $new_rpath, $abs_binpath);
			info_ok(", done\n");
		} else {
			error("$changes changed, $kept kept, $failures failures\n");
		}
	}
}

sub is_elf {
	my ($file)  = @_;
	my $buf;
	open(my $fh, '<', $file) or die "Can't open '$file' for reading: $!";
	sysread($fh, $buf, 4);
	close $fh;

	return $buf eq "\x7fELF";
}

sub install_qt {

	if ( check_qt_install() ) {
		important("Skipping Qt5 build. You can remove $root_dir/qt5-install if you want to force it to be rebuilt.\n");
		return;
	}


	info("\n\n");
	important("############################################################\n");
	important("# Starting Qt build\n");
	important("############################################################\n");
	info("\n");


	mkdir($root_dir);
	chdir($root_dir);
#	run("git", "clone", "--recursive", $qt_repo

	if ( $DD->{qt_repo} ) {
		# Override the repository if the config has an URL
		$qt_repo = $DD->{qt_repo};
	}

	get_source_from_git($qt_repo, "qt5",  $DD->{qt_version});


	info("Applying patches...\n");
	chdir("$root_dir/qt5");

	foreach my $patch ( @{ $DD->{qt_patches} } ) {
		run("patch", "-p1", "-i", "$root_dir/source/tools/qt-builder/patches/$patch");
	}

	info("Configuring paths...\n");
	my $xlib_path  = find_lib_dir('libX11.so', @x11_lib_paths);
	my $gllib_path = find_lib_dir('libGL.so', @x11_lib_paths);

	edit_qt_conf(
		"$root_dir/qt5/qtbase/mkspecs/linux-g++-64/qmake.conf",
		QMAKE_LIBDIR_X11    => $xlib_path,
		QMAKE_LIBDIR_OPENGL => $gllib_path
	);



	del_dir("$root_dir/qt5-install");
	del_dir("$root_dir/qt5-build");

	mkdir("$root_dir/qt5-install");
	mkdir("$root_dir/qt5-build");

	chdir("$root_dir/qt5-build");

	# The build process calls Ninja for QtWebEngine, which calculates the number of processes
	# on its own. Fortunately there's an environment variable we can use to rein it in.
	#
	# This var can be found referenced in
	# qtwebengine/src/core/gn_run.pro
	$ENV{NINJAFLAGS} = "-j${build_cores_qt}";

	my @extra_qt_arguments = ();
	push @extra_qt_arguments, "-debug"            if ( $opt_qt_debug );
	push @extra_qt_arguments, "-force-debug-info" if ( $opt_qt_debug_info );

	my $platform;
    if ( $arch eq "x86_64" ) {
		$platform = "linux-g++-64";
	} elsif ( $arch eq "aarch64" ) {
		$platform = "linux-g++";
	} else {
		fatal("Architecture $arch not supported");
	}

	run("../qt5/configure", "-opensource", "-confirm-license",
		"-platform", $platform,
		@{ $DD->{qt_configure_arguments} },
		@extra_qt_arguments,
		"-prefix", "../qt5-install");

	check_qt_webengine();
	run("make", "-j${build_cores_qt}");
	run("make", "-j${build_cores_qt}", "install");
}

sub setup_qt {
	if (check_qt_install()) {
		# Already installed
		return;
	}

	info("Looking for downloaded Qt's location... ");

	for my $path ("$root_dir/vcpkg", "$ENV{HOME}/hifi") {
		info("$path ");

		my $qt_dir = read_from_cmd("find", $path, "-type", "d", "-name", "qt5-install");
		chomp $qt_dir;

		if ( -d "$qt_dir" ) {
			info_ok("found!\n");

			info("Creating permanent qt dir... ");
			if ( -d "$root_dir/qt5-install" ) {
				run("rm", "-rf", "$root_dir/qt5-install");
			}
			run("cp", "-Rdp", $qt_dir, "$root_dir/qt5-install");

			info_ok("done.\n");
			return;
		}
	}

	fatal("Failed to find Qt dir in $root_dir/vcpkg!");
}

sub setup_scripts {
	foreach my $target (keys %$all_targets) {
		if ( -x "$root_dir/build/$target/$target" ) {
			info("Creating script for $target...");
			create_script($target, "$target/$target");
			info_ok("done.\n");
		}
	}
}

sub setup_services {
	my $services_created;

	foreach my $target (keys %$all_targets) {
		my $t = $all_targets->{$target};
		next unless ($t->{service});

		if ( -x "$root_dir/build/$target/$target" ) {
			info("Creating service for $target...");
			create_service( user => 1, name => $target, args => $t->{service_args}, desc => $t->{service_desc} );
			info_ok("done.\n");

			$services_created = 1;
		}
	}

	unless($opt_skip_systemd_restart) {
		if ( $services_created ) {
			info("Reloading systemd config... ");
			run({ fail_ok => 1 }, "systemctl", "--user", "daemon-reload");

			info_ok("done.\n");
		}
	}
}


sub setup_desktop {
	info("\n\n");
	important("############################################################\n");
	important("# Setting up desktop\n");
	important("############################################################\n");
	info("\n");


	if ( ! -x "$root_dir/build/interface/interface" ) {
		info("interface not built, skipping desktop setup\n");
		return;
	}


	mkdir($desktop);
	create_script("interface", "interface/interface");

	mkdir("$ENV{HOME}/.local");
	mkdir("$ENV{HOME}/.local/share");
	mkdir("$ENV{HOME}/.local/share/applications");
	my $desktop_file = "$ENV{HOME}/.local/share/applications/$fork_name.desktop";

	link("$root_dir/source/interface/icon/interface.ico", "$binary_dir/interface.ico");
	create_desktop_file($desktop_file, "$binary_dir/run_interface", "$binary_dir/interface.ico");

	info("Creating a link in the user's desktop... ");
	mkdir($desktop);
	unlink("$desktop/$fork_name.desktop") if ( -e "$desktop/$fork_name.desktop" );

	if ( symlink($desktop_file, "$desktop/$fork_name.desktop") ) {
		info_ok("done.\n");
	} else {
		warning("failed: $!\n");
	}

	info("Marking desktop icon as trusted...\n");
	run({ fail_ok => 1 }, "gio", "set", $desktop_file, "metadata::trusted", "yes");

	info("Adding to menu...\n");
	run({ fail_ok => 1 }, "xdg-desktop-menu", "install", "--novendor", $desktop_file);

	info_ok("All done!\n");
}

sub create_desktop_file {
	my ($desktop_file, $application, $icon) = @_;

	info("Creating desktop icon for $application... ");
	open(my $dsk, ">", $desktop_file) or fatal("Can't create $desktop_file: $!");
	print $dsk "[Desktop Entry]\n";
	print $dsk "Version=1.0\n";
	print $dsk "Name=$fork_name\n";
	print $dsk "Terminal=false\n";
	print $dsk "Type=Application\n";
	print $dsk "Exec=$application\n";
	print $dsk "Icon=$icon\n" if ($icon);
	print $dsk "Categories=Graphics;AudioVideo;Network;\n";
	close $dsk;
	info_ok("done.\n");
}


sub create_script {
	my ($name, $command) = @_;

	open(my $script, ">", "$root_dir/build/run_$name") or fatal("Can't create $root_dir/build/run_$name: $!");
	my $args = "";

	if ( $command =~ /assignment/ ) {
		$args = "-n 6"
	}

	print $script "#!/bin/bash\n";
	print $script 'SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"' . "\n";

	if (!$using_system_qt) {
		print $script "export QT_DIR=\$SCRIPT_DIR/../qt5-install\n";
		print $script "export QT_QPA_PLATFORM_PLUGIN_PATH=\$QT_DIR/plugins\n";
		print $script "export LD_LIBRARY_PATH=\$QT_DIR/lib:\$LD_LIBRARY_PATH\n";
		print $script "export PATH=\$QT_DIR/bin:\$QT_DIR/libexec:\$PATH\n";
		print $script "export QTWEBENGINEPROCESS_PATH=\$QT_DIR/libexec/QtWebEngineProcess\n";
	}

	print $script "exec \"\$SCRIPT_DIR/$command\" $args \"\$@\"\n";
	close $script;
	chmod 0755,  "$root_dir/build/run_$name";

	link("$root_dir/build/run_$name", "$inst_dir/run_$name") if (!$opt_skip_install);
}


sub create_service {
	my (%args) = @_;

	my @dirs;
	if ( $args{user} ) {
		@dirs = ($ENV{'HOME'}, ".config", "systemd", "user");
	}


	mkdir_path(@dirs);

	my $unit_path = join_path(@dirs, $args{name} . ".service");

	open(my $serv, '>', $unit_path) or fatal("Can't create $unit_path: $!");
	print $serv "[Unit]\n";
	print $serv "Description=$args{desc}\n";
	print $serv "After=network.target\n";
	print $serv "\n";
	print $serv "[Service]\n";
	print $serv "WorkingDirectory=$root_dir/build/$args{name}\n";
	print $serv "Environment=\"LD_LIBRARY_PATH=$root_dir/build/$args{name}\"\n";
	print $serv "Environment=\"HIFI_ENVIRONMENT=production\"\n";
	print $serv "ExecStart=$root_dir/build/$args{name}/$args{name} " . join(' ', @{$args{args}}) . "\n";
	print $serv "Restart=on-failure\n";
	print $serv "RestartSec=5s\n";
	print $serv "\n";
	print $serv "[Install]\n";

	if ( $args{user} ) {
		print $serv "WantedBy=default.target\n";
	} else {
		print $serv "WantedBy=multi-user.target\n";
	}

	close $serv;
}




sub join_path {
	my (@parts) = @_;
	return join('/', @parts);
}

sub sudo_run {
	my (@command) = @_;
	my $run_args = {};

	if ( ref($command[0]) eq "HASH" ) {
		$run_args = shift @command;
	}

	important("Root privileges are needed to run the following command:\n");
	important("\t" . join(' ', @command) . "\n");
	important("Please enter your password to continue\n\n");

	run($run_args, "sudo", @command);

}

sub calculate_cores {
	my ($name, $mem_per_core) = @_;
	info("Checking how many cores to use for building $name... ");

	my $core_count =  grep { /^processor/ } readfile("/proc/cpuinfo");
	my ($mem_avail) = grep { /^MemAvailable/ } readfile("/proc/meminfo");

	info_ok("$core_count cores");

	$mem_avail =~ /:\s*(\d+)/;
	$mem_avail = $1;


	my $cores = $core_count;
	if ( $cores >= ($mem_avail / $mem_per_core )) {
		$cores = int($mem_avail / $mem_per_core);
		$cores = 1 unless ($cores);
		warning(", memory limited to $cores");

	}
	info_ok("\n");

	return $cores;
}

sub get_desktop {
	info("Detecting desktop location... ");

	my $desktop = read_from_cmd({ fail_ok => 1 }, "xdg-user-dir", "DESKTOP");
	if (!$desktop) {
		$desktop = "$ENV{HOME}/Desktop";
	}

	chomp $desktop;
	info_ok($desktop . "\n");

	return $desktop;
}


sub readfile {
	my ($file) = @_;
	debug("READFILE: $file\n");

	open(my $fh, $file) or fatal("Can't open $file: $!");
	my @data = <$fh>;
	chomp @data;
	close $fh;

	debug(join("\n", @data));
	return @data;
}

sub get_source_from_git {
	my ($url, $destdir, $tag, %opts) = @_;

	info("Getting source from git $url ($tag)...\n");

	if ( ! -d "$root_dir/$destdir/.git" ) {
		clone_repo($url, $destdir, $tag, %opts);
	} else {
		info("Checking if updating the existing source is possible... ");

		chdir("$root_dir/$destdir") or fatal("Can't chdir into $root_dir/$destdir: $!");
		my @remotes = read_from_cmd("git", "remote", "-v");
		my $no_update;

		foreach my $line (@remotes) {
			my ($name, $remote) = split(/\s+/, $line);
			if ( $name ne "origin" ) {
				info_ok("no, additional remote $name present.\n");
				$no_update=1;
				last;
			}

			if ( $remote ne $url ) {
				info_ok("no, url '$remote' differs from wanted URL.\n");
				$no_update=1;
				last;
			}
		}

		chdir($root_dir);

		if ( $no_update ) {
			clone_repo($url, $destdir, $tag, %opts);
		} else {
			info_ok("yes\n");
			update_repo($url, $destdir, $tag, %opts);
		}
	}
}

sub clone_repo {
	my ($url, $destdir, $tag, %opts) = @_;
	my @git_extra_args;

	info("Checking $root_dir/$destdir... ");
	if ( -d "$root_dir/$destdir" ) {
		run("rm", "-rf", "$root_dir/$destdir");
		info_ok("deleted for a clean clone.\n");
	} else {
		info_ok("ok.\n");
	}

	if ( exists $opts{git_args} ) {
		@git_extra_args = @{$opts{git_args}};
	}

	if ( $opts{pr} ) {
		my $pr = $opts{pr};
		info("Checking out PR $pr\n");
		run("git", "clone", "--progress", $url, "$root_dir/$destdir");
		run("git", "fetch", "origin", "pull/$pr/head:PR-$pr");
		run("git", "checkout", "PR-$pr");
	} else {
		run("git", "clone", "--progress", $url, "$root_dir/$destdir", "-b", $tag);
	}

	if (!$opts{'no_submodules'}) {
		run("git", "-C", "$root_dir/$destdir", "submodule", "update", "-f", "--init", "--recursive");
	}
}

sub update_repo {
	my ($url, $destdir, $tag, %opts) = @_;

	if ( ! -d "$root_dir/$destdir/.git" ) {
		fatal("Can't update $root_dir/$destdir: there doesn't seem to be a git repo there!");
	}

	info_ok("Already cloned, updating...\n");

	if ( !$opt_keep_source ) {
		chdir("$root_dir/$destdir");
		run("git", "fetch", "origin", "$tag:refs/remotes/origin/$tag");
		run("git", "submodule", "update", "-f", "--init", "--recursive") unless ($opts{'no_submodules'});
		run("git", "clean", "-f");

		if ( $opts{pr} ) {
			my $pr = $opts{pr};
			info("Checking out PR $pr\n");
			run("git", "fetch", "origin", "pull/$pr/head:PR-$pr");
			run("git", "checkout", "PR-$pr");
		} else {
			run("git", "checkout", "origin/$tag");
		}
	}

}

sub edit_qt_conf {
	my ($file, %values) = @_;

	info("Editing qt config file $file... ");

	open(my $rh, "<", $file) or fatal("Failed to open $file: $!");
	open(my $wh, ">", "$file.new") or fatal("Failed to create $file.new: $!");
	while(my $line = <$rh>) {
		if ( $line =~ /^(\w+)\s*=\s*(.*?)$/ && exists $values{$1} ) {
			print $wh "$1=$values{$1}\n";
			delete $values{$1};
		} else {
			print $wh $line;
		}
	}

	close $wh;
	close $rh;

	rename("$file.new", $file) or fatal("Failed to rename $file.new to $file: $!");

	if ( %values ) {
		fatal("Failed to find settings when editing $file: " . join(', ', keys %values));
	}

	info_ok("done.\n");
}


sub find_lib_dir {
	my ($lib, @paths) = @_;
	info("Trying to find where $lib is... ");
	foreach my $dir (@paths) {
		if ( -f "$dir/$lib" || -l "$dir/$lib" ) {
			info_ok("Found in $dir\n");
			return $dir;
		}
	}

	fatal("Failed! Looked in: " . join(', ', @paths));
}

sub find_qt_cmake_dir {
	info("Trying to find where system Qt is... ");
	foreach my $dir (@system_qt_paths) {
		if ( -d "$dir/Qt5WebEngine" ) {
			info_ok("$dir\n");
			return $dir;
		}
	}

	fatal("Failed! Looked in " . join(', ', @system_qt_paths));
}

sub del_dir {
	my ($dir) = @_;

	info("Ensuring $dir doesn't exist... ");
	if ( -d "$dir" ) {
		run("rm", "-rf", $dir);
		info_ok("deleted.\n");
	} else {
		info_ok("ok.\n");
	}
}


sub check_qt_install {
	info("Checking whether Qt is already installed... ");

	if ( -f "$root_dir/qt5-install/lib/libQt5Widgets.so" || -l "$root_dir/qt5-install/lib/libQt5Widgets.so" ) {
		info_ok("yes.\n");
		return 1;
	} else {
		info_ok("no.\n");
		return 0;
	}
}

sub ver_parse {
	my ($ver) = @_;
	$ver =~ s/^[^0-9]+//;  # Remove any leading non-digits
	$ver =~ s/[^0-9.].*?$//; # Remove anything starting from a non-digit at the end

	my ($maj, $min, $rev) = split(/\./, $ver);
	return ($maj * 1000000) + ($min*1000) + $rev;
}


sub check_qt_webengine {
	# This checks if QtWebEngine is going to be built, and if any required dependencies
	# are missing. This works by parsing config.summary, which seems very clunky.
	#
	# This is necessary because Qt will build fine without WebEngine, but then
	# the interface will fail to build.
	#
	# Improvements are welcome.

	info("Checking QtWebEngine configuration... ");

	open(my $fh, '<', "$root_dir/qt5-build/config.summary")
		or fatal("Can't open $root_dir/qt5-build/config.summary: $!");


	# Number of sections we need to find in the output to make sure the
	# config came out okay. This varies by Qt version. We find 3 for 5.14
	# and below, and only 2 for 5.15.
	my $sections_needed = $DD->{qt_check_sections} // 3;
	if ( ver_parse($DD->{qt_version}) >= ver_parse('5.15.0') ) {
		$sections_needed = 2;
		debug("Using $sections_needed for section check for Qt 5.15");
	}

	my $sections_found = 0;
	my $lines_found = 0;

	my $in_webengine;
	my $in_req;
	my $in_req_sys_qpa;
	my @missing;


	while(my $line = <$fh>) {
		chomp $line;


		if ( $line =~ /^WARNING: (.*?) is required to build QtWebEngine/ ) {
			push @missing, $1;
		}

		if ( $line !~ /^\s+/ || $line =~ /^\s*$/ ) {
			# Line doesn't start with a space, or the line is empty
			undef $in_webengine;
			undef $in_req;
		}

		if ( $line !~ /^\s{4}/ ) {
			undef $in_req;
		}

		# The second option is for Qt 5.14
		if ( $line =~ /^(Qt WebEngine|Qt WebEngine Build Tools):/ ) {
			$in_webengine = 1;
			$sections_found++;
			next;
		}

		# The second option is for Qt 5.14
		if ( $in_webengine && $line =~ /^  (Required|QtWebEngine required)/ ) {
			$in_req = 1;
			$sections_found++;
			next;
		}

		if ( $in_req ) {
			if ( $line =~ /^\s*(.*?)[ .]+(\w+)$/ ) {
				$lines_found++;

				my ( $dep, $val ) = ($1, $2);
				if ( $val =~ /no/i ) {
					push @missing, $dep;
				}
			} else {
				fatal("Failed to parse line '$line' in $root_dir/qt5-build/config.summary");
			}
		}

	}
	close $fh;

	if ($sections_found < $sections_needed) {
		fatal("Failed to parse $root_dir/qt5-build/config.summary: only $sections_found of $sections_needed sections were found");
	}

	if ($lines_found < 5) {
		# There are 11 lines in Qt 5.12.6.
		# We don't care about the exact amount, just that something matched and the result is plausible.
		fatal("Failed to parse $root_dir/qt5-build/config.summary: only $lines_found lines were found inside the sections");
	}


	if (@missing) {
		fatal("Missing QtWebEngine dependencies: " . join(', ', @missing));
	} else {
		info_ok("ok.\n");
	}
}




sub get_supported {
	foreach my $k ( sort keys %$data ) {
		print "$k\n";
	}
	exit(0);
}

sub get_conf {
	my ($key, $dist) = @_;
	unless(exists $data->{$dist}) {
		print STDERR "No such distribution: '$dist'. Try $0 --get-supported\n";
		exit(1);
	}

	unless( exists $data->{$dist}->{$key} ) {
		print STDERR "$key not defined in the config for distro '$dist'\n";
		exit(1);
	}


	if ( ref($data->{$dist}->{$key}) eq "ARRAY" ) {
		foreach my $pkg ( @{ $data->{$dist}->{$key} } ) {
			print "$pkg\n";
		}
	} else {
		print $data->{$dist}->{$key} . "\n";
	}

	exit(0);
}

sub make_pkglist {
	my @packages;
	while(my $line = <STDIN>) {
		chomp $line;
		my @pkgs = grep { $_ } split(/\s+/, $line);
		push @packages, @pkgs;
	}

	foreach my $pkg ( sort @packages ) {
		print "\t\t\t\'$pkg',\n";
	}

	exit(0);
}

sub parse_build_option {
	my ($optval) = @_;


	# Valid aliases (names for groups of targets)
	my @all_aliases = qw( all client server );

	my %all_valid = map { $_ => 1 } (@all_aliases, keys %$all_targets);
	my %split = map { $_ => 1 } split(/,/, $optval);
	my @out;

	if ( $split{all} ) {
		delete $split{all};
		foreach my $t (keys %$all_targets) {
			$split{$t} = 1;
		}
	}

	if ( $split{client} ) {
		delete $split{client};
		$split{'interface'}        = 1;
	}

	if ( $split{server} ) {
		delete $split{server};
		$split{'domain-server'}     = 1;
		$split{'assignment-client'} = 1;
	}

	if ( $split{'jsdoc'} ) {
		# Horrible hack to deal with vircadia/vircadia#513 -- part 2
		# ensure we build jsdoc first
		push @out, 'jsdoc';
		delete $split{jsdoc};
	}

	foreach my $k ( keys %all_valid ) {
		push @out, $k if exists $split{$k};
		delete $split{$k};
	}

	debug("Parsed build targets: " . join(', ', @out));

	if ( %split ) {
		my $bad = join(', ', keys %split);

		print STDERR "Bad value '$bad' for build option, only these values are valid:\n";
		print STDERR  join(', ', sort keys %all_valid) . "\n\n";
		print STDERR "You probably want one of:\n";
		print STDERR "\tclient      Build the graphical desktop client. This is the default.\n";
		print STDERR "\t            Choosing this option builds the 'interface' target\n\n";
		print STDERR "\tserver      Build the components needed to create a server (domain)\n";
		print STDERR "\t            Choosing this option builds domain-server and assignment-client\n\n";
		print STDERR "\tall         Build everything, including development and testing tools\n";
		print STDERR "\nTry $0 --help for more information on the command-line arguments\n";
		exit(1);
	}

	return @out;
}


##########################################################################
# AppImage
##########################################################################

#sub get_library_paths {
#	my $ret;
#
#	foreach my $dir (@ext_lib_paths) {
#		$ret .= ":" if ($ret);
#		$ret .= "$root/$dir";
#
#		if ( ! -d "$root/$dir" ) {
#			fatal("Can't find library path: $root/$dir");
#		}
#	}
#
#	return $ret;
#}

sub file_is_under_dir {
	my ($file, $dir) = @_;

	my $abs_file = abs_path($file);
	my $abs_dir = abs_path($dir);

	return substr($abs_file, 0, length($abs_dir)) eq $abs_dir;
}

sub download_appimage_tool {
	my $tool_path = "$root_dir/appimagetool.${appimagetool_release}";

	if (!-f $tool_path) {
		run("curl", "-L", $appimagetool_url, "-o", $tool_path);
		chmod 0755, $tool_path;
	}
}

sub install_into_appimage {
	# This is a bit of a mess. The AppImage tools want a normal, well-behaved
	# application, and choke on all this qt5-install and vcpkg weirdness.
	#
	# They also want the binary to be in usr/bin, rather than where we have it.
	#
	# So we skip all of that, generate a non-standard layout by hand, and just
	# package it up.
	#
	# This should get a lot nicer once the Vircadia tree gets a better packaging
	# process that makes things go in the places they're supposed to on a normal
	# Linux system. But meanwhile, we have this.

	info("\n\n");
	important("############################################################\n");
	important("# Installing into AppImage\n");
	important("############################################################\n");
	info("\n");

	# Another horrible hack for vircadia/vircadia#513
	@build_list = grep { !/jsdoc/ } @build_list;

	if ( scalar(@build_list) > 1 ) {
		fatal("Can't create AppImage of more than one target, skipping\n");
		return;
	}

	my ($target) = @build_list;
	if ( $all_targets->{$target}->{is_service} ) {
		fatal("Can't create AppImage for a systemd service, skipping\n");
		return;
	}

	my $appimage_base    = "$root_dir/$fork_name.AppImage";
	my $appimage_instdir = "$appimage_base/$opt_fork";
	my $appimage_qtdir   = "$appimage_base/qt5-install";
	my $tool_path        = "$root_dir/appimagetool.${appimagetool_release}";

	# We want to start from scratch every time
	if ( -d "$appimage_base" ) {
		info("Cleaning $appimage_base... ");
		run("rm", "-rf", $appimage_base);
		info_ok("done.\n");
	}

	# We create this structure here:
	# AppImage/qt5-install -- qt dir
	# AppImage/vircadia/interface/interface -- binary
	#
	# This ensures it goes together just like it does in
	# $VircadiaRoot/qt5-install and $VircadiaRoot/install_*
	# and the relative paths keep working.
	#
	# Also, unlike with the install, for AppImage generation, we will modify the Qt libraries,
	# so the directory must be copied rather than linked.

	info("Copying $fork_name files to $appimage_instdir\n");
	mkdir($appimage_instdir);

	find({ follow      => 1,
	       follow_skip => 2,
	       wanted      => sub { install_search_func("$root_dir/build", $appimage_instdir, "copy") }},
	       "$root_dir/build");

	# Clear line
	info( "\r" . (" " x $prev_len) . "\r");

	info("Copying Qt5 files to $appimage_qtdir\n");

	if ($using_system_qt ) {
		info("Using system Qt\n");
	} elsif ( -d "$root_dir/qt5-install" ) {
		# We've built Qt locally
		run("cp", "-rdp", "$root_dir/qt5-install", $appimage_qtdir);
	} else {
		# Qt was downloaded by cmake
		run("cp", "-rdp", "$files_dir/qt/qt5-install", $appimage_qtdir);
	}

	# Clear line
	info( "\r" . (" " x $prev_len) . "\r");

	info("Copied : "); info_ok("$inst_copied\n");
	info("Skipped: "); info_ok("$inst_skipped\n");
	info("Deleted: "); info_ok("$inst_deleted\n");
	info("\n");

	info("Creating icons... ");
	run("convert", "$root_dir/source/interface/icon/interface.ico", "$appimage_base/interface.png");
	my $max_size = 0;
	foreach my $icon (glob("$appimage_base/interface-*.png")) {
		my $type = read_from_cmd("file", "-b", $icon);
		chomp $type;
		my ($png, $res, $color) = split(/\s*,\s*/, $type);
		$res =~ s/\s*//g;
		my $size = split(/x/, $res);

		info_ok("$res, ");
		my $icon_path     = "$appimage_base/usr/share/icons/hicolor/$res/apps";
		my $icon_filename = "$icon_path/$fork_name.png";

		mkdir_path($icon_path);
		rename($icon, $icon_filename);

		if ( $max_size < $size ) {
			$max_size = $size;
			symlink("usr/share/icons/hicolor/$res/apps/$fork_name.png", "$appimage_base/$fork_name.png");
		}

	}
	info_ok("done.\n");

	mkdir_path("$appimage_base/usr/bin");
	symlink("../../$opt_fork/interface/interface", "$appimage_base/usr/bin/$fork_name");

	#create_desktop_file("$appimage_base/$fork_name.desktop",
	#                    "$fork_name", "$fork_name");

	#mkdir_path("$appimage_base/usr/share/applications");
	$template->write_appimage_desktop_file($appimage_base,
	                                       icon        => "/${fork_name}",
										   application => "/AppRun"
										  );


	if (!$using_system_qt) {
		$template->write_appimage_packaged_qtconf_file($appimage_base);
	}

	info("Finding library dependencies...\n");
	my @dep_list = ldd("$root_dir/build/$target/$target");

	info("Finding plugins...\n");
	my @plugin_dirs = ("$root_dir/qt5-install/plugins/platforms", "$root_dir/build/$target/plugins");
	if ( $using_system_qt ) {
		push @plugin_dirs, "/usr/lib64/qt5/plugins";
		push @plugin_dirs, "/usr/lib/x86_64-linux-gnu/qt5/plugins";
	}

	foreach my $plugin_dir (@plugin_dirs) {
		info("Trying $plugin_dir... ");
		if ( -d "$plugin_dir" ) {
			info_ok("found, scanning...\n");

			find(sub {
				my $file = $File::Find::name;
				return unless $file =~ /\.so$/;
				push @dep_list, ldd($File::Find::name);
				}, $plugin_dir);
			info_ok("done.\n");
		} else {
			warning("not found, skipping\n");
		}
	}

	# Some files don't seem to be properly detected as dependencies, probably loaded
	# at runtime with dlopen. Force them into the package.

	info("Finding additional system libraries...\n");
	foreach my $libdir (@system_lib_paths) {
		info("\t$libdir:\n");
		if (!-d "$libdir") {
			warning("\t\t(directory missing, skipping)\n");
			next;
		}

		find(
			sub {
				my $file = basename($File::Find::name);

				foreach my $regex (@included_system_libs) {
					if ( $file =~ /$regex/ ) {
						push @dep_list, $File::Find::name;
						info("\t\t$file\n");
					}
				}
			}, $libdir);
	}


	my %deps = map { $_ => 1 } @dep_list;


	info("Copying missing system libraries... ");
	mkdir_path("$appimage_base/usr/lib64");

	foreach my $dep (sort keys %deps) {

		# We're copying dependencies that are not located inside the build directory,
		# as those have been dealt with earlier.
		#
		# We make an exception here about dependencies that remain in vcpkg, because otherwise
		# those would not be copied at all into the AppImage.
		if ( file_is_under_dir($dep, $root_dir) && !file_is_under_dir($dep, "$root_dir/vcpkg") ) {
			info("-");
			next;
		}

		info(".");

		# The dependency list we get points to the actual filename the binary wants.
		# If this turns out to be a symlink, then we copy the file it points to, and
		# create a symlink at the destination.
		if ( -l $dep ) {
			cp($dep, "$appimage_base/usr/lib64/" . basename(readlink($dep)));
			symlink(basename(readlink($dep)), "$appimage_base/usr/lib64/" . basename($dep));
		} else {
			cp($dep, "$appimage_base/usr/lib64/");
		}
	}

	if (!$using_system_qt && !$opt_disable_sanity_check && glob("$appimage_base/usr/lib64/libQt*")) {
		# If anything gets compiled against system qt, the likely outcome
		# is weird issues, such as the binary hanging on startup, probably due to multiple
		# incompatible versions of Qt being loaded by interface.
		#
		# So far this has been a possible issue with libquazip
		my $msg = "Sanity check failed: something has been built against system Qt, even though system Qt is not enabled.\n";
		$msg   .= "The following incorrect libraries have been found as dependencies:\n";
		$msg   .= join(', ', glob("$appimage_base/usr/lib64/libQt*"));

		fatal($msg);
	}

	chmod(0755, glob("$appimage_base/usr/lib64/*"));

	info_ok("done.\n");

	info("Adjusting rpath...");
	find({ follow      => 1,
	       follow_skip => 2,
	       wanted      => sub { add_lib_path_search_func("$appimage_base/usr/lib64", "$appimage_base/qt5-install/lib"); }},
	       $appimage_base);

	info_ok("done.\n");

	info("Cleaning up any duplicates...\n");
	# AppImage
	run({ fail_ok => 1}, "rdfind", "$appimage_base", "-makesymlinks", "true", "-dryrun", "false");


	info("Creating AppRun... ");
	$template->write_appimage_apprun_file($appimage_base);

	info_ok("done.\n");

	info("Writing AppStream metadata");
	$template->write_appstream($appimage_base);

	info("Creating AppImage...\n");
	chdir($root_dir);
	my $appimage_filename = $template->fork_id . "-" . $template->version . "-debug-" . $arch . ".AppImage";

	# appimagetool can complain about architecture, just give it the system one.
	$ENV{ARCH} = $architecture;


	my ($appstream_major, $appstream_minor, $appstream_revision) = $template->get_appstream_version();
	my @tool_options;


	if ($appstream_major < 1) {
		# For some reason, Ubuntu 20.04 appstreamcli always fails to find the desktop file:
		# org.overte.interface.appdata.xml
        #  W: org.overte.interface:~: desktop-file-not-found
		#
		# even though it is there. I think it's a bug. So we'll just ignore it.

		warning("Old system appstreamcli, will ignore specification errors\n");
		push @tool_options, "-n";
	}


	run($tool_path, @tool_options, $appimage_base, $appimage_filename);

	info("Stripping symbols for non-debug AppImage...\n");
	find(
		sub {
			my $path = $File::Find::name;
			my $name = basename($path);

			# strip complains if used on non-compatible files, so filter them out
			return if ($name =~ /(AppRun|\._libsteam_api.so|\._libsdkencryptedappticket.so)$/);
			return if ($name =~ /\.(pl|sh|svg|py|)$/);

			if ( -f "$path" && ($name =~ /\.so/ || -x $path)) {
				run({ fail_ok => 1, }, "strip", "--strip-unneeded", "--strip-debug", $File::Find::name);
			}
		}, $appimage_base
	);

	info("Creating stripped AppImage...\n");
	my $appimage_filename_nodebug = $template->fork_id . "-" . $template->version . "-" . $arch . ".AppImage";
	run($tool_path, @tool_options, $appimage_base, $appimage_filename_nodebug);

	info("Created AppImage with debugging   : ");
	info_ok( File::Spec->join($root_dir, $appimage_filename) . "\n");

	info("Created AppImage without debugging: ");
	info_ok( File::Spec->join($root_dir, $appimage_filename_nodebug) . "\n");

	info("\n");
}

sub create_appimage_metadata {
	my ($filename) = @_;

	info("Creating metadata... ");

	my $dir = dirname($filename);
	mkdir_path($dir);


	my $file = $template->write_appstream($dir);
	info_ok("done ($file).\n");
}


sub ldd {
	my ($binary, $seen, $depth) = @_;
	my @deps;
	my @rec_deps;
	my $binary_dir;

	$binary     = abs_path($binary);
	$binary_dir = dirname($binary);
	$seen       //= {};
	$depth      //= 0;

	return if exists $seen->{$binary};
	if (!-e "$binary") {
		fatal("Can't run ldd on '$binary': file not found");
	}

	info("  " x $depth);
	info("$binary...");

	# We force ldd to consider the binary's directory as a location for dependencies,
	# even if the rpath isn't set accordingly, as we're going to add that afterwards
	# anyway, when we copy things into the AppImage dir.
	my $orig_ld_path = $ENV{LD_LIBRARY_PATH};
	$ENV{LD_LIBRARY_PATH} .= ":$binary_dir";
	my @lines = read_from_cmd("ldd", $binary);
	$ENV{LD_LIBRARY_PATH} = $orig_ld_path;

	foreach my $line (@lines) {
		chomp $line;

		next unless ($line =~ /=>/);
		my ($soname, $path) = split(/\s*=>\s*/, $line);
		$soname =~ s/^\s+//;
		$soname =~ s/\s+$//;

		$path =~ s/\s+\([0-9a-fA-Fx]*\)//;

		if ( is_excluded_system_lib($path) ) {
			debug("$soname: excluded\n");
			next;
		}

		if (!$using_system_qt && is_prepackaged_qt_lib($path)) {
			# When we have a pre-built package we ignore files within here,
			# as it will be copied as-is.
			debug("$soname: $path is a pre-packaged Qt library, will be copied later");
			next;
		}

		debug("$soname => $path\n");

		if ( $path eq "not found" ) {
			fatal("Can't find library '$soname' for binary '$binary'");
		}

		# abs_path canonicalizes a path, but that includes resolving
		# symlinks. We don't want that. We want the original filename
		# the binary is referencing.
		my $orig_filename=basename($path);
		$path = File::Spec->catfile(dirname(abs_path($path)), $orig_filename);

		push @deps, $path;
		info(".");
	}

	$seen->{$binary}=1;
	info_ok(" done.\n");

	foreach my $dep (@deps) {
		push @rec_deps, ldd($dep, $seen, $depth+1);
	}

	push @deps, @rec_deps;
	return @deps;
}

sub is_excluded_system_lib {
	my ($path) = @_;

	foreach my $re (@excluded_system_libs) {
		my $filename = basename($path);
		#die "$filename is excluded" if ( $filename =~ /$re/);
		return 1 if ( $filename =~ /$re/ );
	#	if ( $filename =~ /libc/ ) {
	#		warn "$filename passed check $re";
	#	}
	}

	return 0;
}

sub is_prepackaged_qt_lib {
	my ($path) = @_;

	if (file_is_under_dir($path, "${files_dir}/qt/qt5-install")) {
		return 1;
	}

	return 0;
}

# For AppImage, all library paths have to be relative.
# This function calculates the relative paths to the passed library directories, and adds them to
# each binary.
sub add_lib_path_search_func {
	my (@libdirs) = @_;
	my $abspath = $File::Find::name;
	my $absdir  = $File::Find::dir;

	if ( -f $abspath && -x $abspath && !-l $abspath && is_elf($abspath) )  {


		my $rpath = read_from_cmd("patchelf", "--print-rpath", $abspath);
		chomp $rpath;
		my %rpaths = map { $_ => 1 } split(/:/, $rpath);

		$rpaths{'$ORIGIN'} = 1;

		foreach my $libdir (@libdirs) {
			my $rel_libpath = File::Spec->abs2rel($libdir, $absdir);

			if ( $rel_libpath ne "." ) {
				$rpaths{'$ORIGIN/' . $rel_libpath} = 1;
			}
		}

		run("patchelf", "--set-rpath", join(':', sort keys %rpaths), $abspath);
		info(".");
	}
}

sub get_source_version {
	my $tag = read_from_cmd({ fail_ok => 1 }, "git", "-C", "$root_dir/source", "describe", "--tags");
	unless ( $tag ) {
		# If there are no tags, use whatever we can work with. Clean it up a bit so that it's an
		# usable directory name.
		$tag = read_from_cmd({ fail_ok => 1 }, "git", "-C", "$root_dir/source", "describe", "--all");
		$tag =~ s/^heads\///;
		$tag =~ s/\//-/g;
	}
	chomp $tag;
	return $tag;
}

sub get_install_dir_relpath {
	my $tag = get_source_version();
	return lc($fork_name) . "_$tag";
}

sub get_install_dir_path {
	return "$root_dir/" . get_install_dir_relpath();
}

sub get_archive_path {
	return get_install_dir_path . ".tar.xz";
}



sub help {
	my $retval = shift // 0;

	print <<HELP;

$0 [options]
Downloads, compiles and installs $fork_name.

Options:
	-A, --make-appimage     Create an AppImage
	-B, --build-qt          Built Qt even if there's a binary package
	--build TARGET          Selects the build target. Possible values are: server, client, all, domain-server, assignment-client, ice-server, interface, atp-client, oven, nitpick, skeleton-dump, ac-client, ktx-tool, ice-client, gpu-frame-player,vhacd-util (default is client). You can build multiple targets by separating them with a comma.
	--build server,client   Builds server and client (only client
                          is built by default)
	-C, --collect-info      Collect additional info for debugging
	-D, --distro DIST       Set the distribution
	-d, --destdir DIR       Set the installation directory
	-F, --fork FORK         Builds the specified fork. Valid values are Vircadia, Overte and Tivoli
	-h, --help              Shows this text
	-j, --cores NUM         Use NUM cores during main build
	-J, --qt-cores NUM      Use NUM cores during Qt build
	-k, --keep-source       Don't overwrite the current source tree
	-P, --pr PR             Builds the specified pull request. PR is either a PR number, or the URL to the PR on Github
	-r, --repo REPO         Set the repository to REPO
	-t, --tag TAG           Set the tag to TAG
	-T, --build-type type   CMake build type: RelWithDebInfo, Debug, Release, MinSizeRel.
	-v, --verbose           Run a verbose build, showing the full compiler commands
	-y, --auto              Run without asking any questions
	--qt-debug              Build Qt in debug mode
	--qt-debug-info         Build Qt with debug symbols in release mode

Custom mode options:

This script is intended to be user friendly and as automatic as possible, so
it has embedded presets for a number of distributions. However, it can be made
to work without them.

	--get-supported            Lists the distributions that are supported
	--get-source-deps DIST     Lists the packages needed to build the source on
	                           distro DIST.
	--get-system-qt-deps DIST  Lists the packages needed to build against
                               system Qt on distro DIST
	--get-qt-deps DIST         Lists the packages needed to build Qt on distro
	                           DIST.
	--get-qt-version DIST      Outputs the Qt version that will be used if Qt
	                           is built from source on disto DIST.
	--get-qt-patches DIST      Lists the patches that will be applied if Qt
	                           is built from source on distro DIST.
	--make-pkglist             Reads a list of package names from STDIN and
	                           outputs them in a format suitable for pasting
	                           into the script's source code.

HELP


	exit(1);
	exit($retval);
}


sub optimization_preset_is_valid {
	my ($preset) = @_;
	return exists $optimization_presets->{$preset};
}

sub list_optimization_presets {
	important("Optimization presets:\n");

	foreach my $p ( sort keys %$optimization_presets) {
		my $pv = $optimization_presets->{$p};
		important("\t" . pad($p, 16) . ": " . $pv->{description} . "\n");
		important("\t" . pad("", 16) . "  Options: " . $pv->{flags} . "\n");
	}
}

sub pad {
	my ($str, $len) = @_;
	return $str . (" " x ($len - length $str));
}
